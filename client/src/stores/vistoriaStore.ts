import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import type { Client, Tile } from '@shared/schema'; // Removed NonConformity from here, will redefine below

// New Photo Structure
export interface PhotoRepresentation {
  id?: string; // Unique frontend ID (e.g., for React keys) or server ID after sync
  file?: File; // The actual File object for new, unsynced photos
  previewUrl: string; // Blob URL for local preview, or server URL for synced photos
  name?: string; // Original file name
  localDbId?: number; // ID from the local 'photos' table in IndexedDB
  serverId?: string; // ID from the server after photo is uploaded (e.g. Supabase Storage path/id)
  comment?: string; // Optional: if comments are per-photo
  isUploaded?: boolean; // Flag to indicate if the photo (file) has been uploaded
}

// Updated NonConformity structure to use new PhotoRepresentation
export interface NonConformity {
  id: number | string; // Can be a local ID (number) or server ID (string/number)
  inspectionId?: number; // Associated inspection ID
  title: string;
  description?: string;
  notes?: string;
  photos: PhotoRepresentation[]; // Use the new photo structure
  // Add other fields like area, severity, etc. if they are part of your @shared/schema NonConformity
}

import type { Client, Tile } from '@shared/schema'; // Removed NonConformity from here, will redefine below

// New Photo Structure
export interface PhotoRepresentation {
  id: string; // Unique frontend ID (e.g., for React keys, can be `local-${timestamp}` or server ID after sync)
  file?: File; // The actual File object for new, unsynced photos
  previewUrl: string; // Blob URL for local preview, or server URL for synced photos
  name?: string; // Original file name
  localDbId?: number; // ID from the local 'photos' table in IndexedDB
  serverId?: string; // ID from the server after photo is uploaded (e.g. Supabase Storage path/id)
  // comment?: string; // Optional: if comments are per-photo; assuming comments are on NC level for now
  isUploaded?: boolean; // Flag to indicate if the photo (file) has been uploaded
  error?: string; // To store any upload error related to this photo
}

// Updated NonConformity structure to use new PhotoRepresentation
export interface NonConformity {
  id: number | string; // Can be a local ID (number generated by store/db) or server ID (string/number from backend)
  inspectionId?: number | string; // Associated inspection ID (local or server)
  title: string;
  description: string; // Made non-optional for consistency, can be empty string
  notes: string;       // Made non-optional
  photos: PhotoRepresentation[]; // Use the new photo structure
  // Add other fields like area, severity, etc. if they are part of your @shared/schema NonConformity
}


interface VistoriaFormData {
  // Step 1: Client
  client: Client | null;
  
  // Step 2: Basic Info
  date: Date;
  enterprise: string;
  city: string;
  state: string;
  address: string;
  cep: string;
  protocol: string;
  subject: string;
  
  // Step 3: Team (auto-filled from user)
  technician: string;
  department: string;
  unit: string;
  coordinator: string;
  manager: string;
  regional: string;
  
  // Step 4: Tiles
  tiles: Tile[];
  totalArea: number;
  
  // Step 5: Non-conformities
  nonConformities: NonConformity[];
  
  // Form state
  currentStep: number;
  isComplete: boolean;
  isDraft: boolean;
}

interface VistoriaState extends VistoriaFormData {
  // Actions
  setClient: (client: Client | null) => void;
  setBasicInfo: (info: Partial<VistoriaFormData>) => void;
  setTeamInfo: (info: Partial<VistoriaFormData>) => void;
  addTile: (tile: Omit<Tile, 'id' | 'inspectionId'>) => void;
  removeTile: (index: number) => void;
  updateTile: (index: number, tile: Partial<Tile>) => void;
  setTiles: (tiles: Tile[]) => void;
  addNonConformity: (ncData: Omit<NonConformity, 'id' | 'photos'> & { photos?: PhotoRepresentation[] }) => void;
  removeNonConformity: (ncId: number | string) => void;
  updateNonConformity: (ncId: number | string, updates: Partial<Omit<NonConformity, 'id'>>) => void;
  setNonConformities: (nonConformities: NonConformity[]) => void;
  // Actions for photos within a non-conformity
  addPhotoToNonConformity: (ncId: number | string, photo: PhotoRepresentation) => void;
  removePhotoFromNonConformity: (ncId: number | string, photoId: string) => void;
  updatePhotoInNonConformity: (ncId: number | string, photoId: string, updates: Partial<PhotoRepresentation>) => void;
  setCurrentStep: (step: number) => void;
  calculateTotalArea: () => void;
  resetForm: () => void;
  saveDraft: () => void;
  markComplete: () => void;
}

const initialState: VistoriaFormData = {
  client: null,
  date: new Date(),
  enterprise: '',
  city: '',
  state: 'PR',
  address: '',
  cep: '',
  protocol: '',
  subject: '',
  technician: '',
  department: 'Assistência Técnica',
  unit: 'PR',
  coordinator: 'Marlon Weingartner',
  manager: 'Elisabete Kudo',
  regional: 'Sul',
  tiles: [],
  totalArea: 0,
  nonConformities: [],
  currentStep: 1,
  isComplete: false,
  isDraft: false,
};

export const useVistoriaStore = create<VistoriaState>()(
  persist(
    (set, get) => ({
      ...initialState,

      setClient: (client) => set({ client }),

      setBasicInfo: (info) => set((state) => ({ ...state, ...info })),

      setTeamInfo: (info) => set((state) => ({ ...state, ...info })),

      addTile: (tile) => set((state) => {
        const newTiles = [...state.tiles, { ...tile, id: Date.now(), inspectionId: 0 } as Tile];
        return { tiles: newTiles };
      }),

      removeTile: (index) => set((state) => ({
        tiles: state.tiles.filter((_, i) => i !== index)
      })),

      updateTile: (index, tile) => set((state) => ({
        tiles: state.tiles.map((t, i) => i === index ? { ...t, ...tile } : t)
      })),

      setTiles: (tiles) => set({ tiles }), // Implementation for setTiles

      addNonConformity: (ncData) => set((state) => {
        const newNc: NonConformity = {
          ...ncData,
          id: `local-nc-${Date.now()}`, // Generate a temporary local string ID
          photos: ncData.photos || [],
          description: ncData.description || '',
          notes: ncData.notes || '',
        };
        return { nonConformities: [...state.nonConformities, newNc] };
      }),

      removeNonConformity: (ncId) => set((state) => ({
        nonConformities: state.nonConformities.filter(nc => nc.id !== ncId)
      })),

      updateNonConformity: (ncId, updates) => set((state) => ({
        nonConformities: state.nonConformities.map(nc =>
          nc.id === ncId ? { ...nc, ...updates } : nc
        )
      })),

      setNonConformities: (nonConformities) => set({ nonConformities }),

      addPhotoToNonConformity: (ncId, photo) => set(state => ({
        nonConformities: state.nonConformities.map(nc => {
          if (nc.id === ncId) {
            return { ...nc, photos: [...nc.photos, photo] };
          }
          return nc;
        }),
      })),

      removePhotoFromNonConformity: (ncId, photoId) => set(state => ({
        nonConformities: state.nonConformities.map(nc => {
          if (nc.id === ncId) {
            // Revoke blob URL if it exists and is a blob URL
            const photoToRemove = nc.photos.find(p => p.id === photoId);
            if (photoToRemove && photoToRemove.previewUrl.startsWith('blob:')) {
              URL.revokeObjectURL(photoToRemove.previewUrl);
            }
            return { ...nc, photos: nc.photos.filter(p => p.id !== photoId) };
          }
          return nc;
        }),
      })),

      updatePhotoInNonConformity: (ncId, photoId, updates) => set(state => ({
        nonConformities: state.nonConformities.map(nc => {
          if (nc.id === ncId) {
            return {
              ...nc,
              photos: nc.photos.map(p => p.id === photoId ? { ...p, ...updates } : p)
            };
          }
          return nc;
        }),
      })),

      setCurrentStep: (currentStep) => set({ currentStep }),

      calculateTotalArea: () => set((state) => {
        const totalArea = state.tiles.reduce((sum, tile) => {
          return sum + tile.correctedArea;
        }, 0);
        return { totalArea };
      }),

      resetForm: () => set(initialState),

      saveDraft: () => set({ isDraft: true }),

      markComplete: () => set({ isComplete: true, isDraft: false }),
    }),
    {
      name: 'vigitel-vistoria',
      partialize: (state) => ({
        client: state.client,
        date: state.date,
        enterprise: state.enterprise,
        city: state.city,
        state: state.state,
        address: state.address,
        cep: state.cep,
        protocol: state.protocol,
        subject: state.subject,
        tiles: state.tiles,
        totalArea: state.totalArea,
        nonConformities: state.nonConformities,
        currentStep: state.currentStep,
        isDraft: state.isDraft,
      }),
    }
  )
);
